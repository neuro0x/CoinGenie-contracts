{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "lib/v2-periphery/contracts/interfaces/IUniswapV2Migrator.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Migrator {\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\n}\n"
    },
    "lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "src/AirdropERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport { SafeTransfer } from \"./lib/SafeTransfer.sol\";\n\n/**\n * @title AirdropERC20\n * @author @neuro_0x\n * @dev A contract for distributing ERC20 tokens to a list of recipients.\n */\ncontract AirdropERC20 is ReentrancyGuard {\n    error NoRecipients();\n    error TokenAddressZero();\n    error NotERC20();\n    error InsufficientBalance();\n    error InsufficientAllowance();\n\n    /// @dev The address of the native token (ETH).\n    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when an failed airdrop occurs.\n    event AirdropFailed(\n        address indexed tokenAddress, address indexed tokenOwner, address indexed recipient, uint256 amount\n    );\n\n    /**\n     * @dev Details of amount and recipient for airdropped token.\n     * @param recipient The recipient of the tokens.\n     * @param amount The quantity of tokens to airdrop.\n     */\n    struct AirdropContent {\n        address recipient;\n        uint256 amount;\n    }\n\n    /**\n     * @notice Allows the user to distribute ERC20 tokens to a list of addresses.\n     * @param tokenAddress The address of the token to be airdropped.\n     * @param tokenOwner The address of the token owner initiating the airdrop.\n     * @param contents A list of recipients and amounts for the airdrop.\n     *\n     * @dev needs Approval\n     *\n     */\n    function airdrop(\n        address tokenAddress,\n        address tokenOwner,\n        AirdropContent[] calldata contents\n    )\n        external\n        payable\n        nonReentrant\n    {\n        if (contents.length == 0) {\n            revert NoRecipients();\n        }\n\n        if (tokenAddress == address(0)) {\n            revert TokenAddressZero();\n        }\n\n        if (tokenAddress == NATIVE_TOKEN) {\n            revert NotERC20();\n        }\n\n        uint256 len = contents.length;\n        for (uint256 i = 0; i < len;) {\n            // Attempt to transfer the specified amount of tokens to the recipient\n            bool success =\n                _transferCurrencyWithReturnVal(tokenAddress, tokenOwner, contents[i].recipient, contents[i].amount);\n\n            if (!success) {\n                // Log the failed transfer\n                emit AirdropFailed(tokenAddress, tokenOwner, contents[i].recipient, contents[i].amount);\n            }\n\n            // Increment the counter\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to transfer the specified currency (either ERC20 or native) from the sender to the recipient.\n     * @param _currency The address of the currency to be transferred.\n     * @param _from The sender's address.\n     * @param _to The recipient's address.\n     * @param _amount The amount to be transferred.\n     * @return success A boolean indicating if the transfer was successful.\n     */\n    function _transferCurrencyWithReturnVal(\n        address _currency,\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        private\n        returns (bool success)\n    {\n        // If _amount is zero, return true\n        if (_amount == 0) {\n            success = true;\n            return success;\n        }\n\n        // Attempt to transfer if the currency is the native token (ETH)\n        if (_currency == NATIVE_TOKEN) {\n            (success,) = _to.call{ value: _amount }(\"\");\n        } else {\n            // Attempt to transfer if the currency is an ERC20 token\n            (bool success_, bytes memory data_) = // solhint-disable-next-line avoid-low-level-calls\n             _currency.call(abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _amount));\n\n            success = success_;\n\n            // If the transfer failed, check the allowance and balance\n            if (!success || (data_.length > 0 && !abi.decode(data_, (bool)))) {\n                success = false;\n\n                if (IERC20(_currency).balanceOf(_from) < _amount) {\n                    revert InsufficientBalance();\n                }\n\n                if (IERC20(_currency).allowance(_from, address(this)) < _amount) {\n                    revert InsufficientAllowance();\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Safely transfers ERC20 tokens from the sender to the recipient.\n     * @param _currency The address of the ERC20 token to be transferred.\n     * @param _from The sender's address.\n     * @param _to The recipient's address.\n     * @param _amount The amount to be transferred.\n     */\n    function _safeTransferERC20(address _currency, address _from, address _to, uint256 _amount) private {\n        // if _from is _to, return\n        if (_from == _to) {\n            return;\n        }\n\n        // If _from is the contract, transfer the ERC20 token\n        if (_from == address(this)) {\n            SafeTransfer.safeTransfer(_currency, _to, _amount);\n        } else {\n            // Otherwise, transfer the ERC20 token via the allowance mechanism\n            SafeTransfer.safeTransferFrom(_currency, _from, _to, _amount);\n        }\n    }\n}\n"
    },
    "src/AirdropERC20Claimable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport { MerkleProof } from \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title AirdropERC20Claimable\n * @author @neuro_0x\n * @dev A contract for airdropping ERC20 tokens to specific recipients based on Merkle proofs.\n */\n\ncontract AirdropERC20Claimable {\n    error InvalidTransferAmount();\n    error AirdropExpired();\n    error AlreadyClaimedMax();\n    error TransferFailed();\n    error InvalidAirdropParameters(address tokenOwner, address airdropTokenAddress, uint256 airdropAmount);\n\n    /// @dev The address of the token to be airdropped.\n    address public airdropTokenAddress;\n\n    /// @dev The owner of the token to be airdropped.\n    address public tokenOwner;\n\n    /// @dev The quantity of tokens available for airdrop.\n    uint256 public availableAmount;\n\n    /// @dev Expiration timestamp of the airdrop.\n    uint256 public expirationTimestamp;\n\n    /// @dev Maximum number of tokens that can be claimed by a wallet if not in the whitelist.\n    uint256 public maxWalletClaimCount;\n\n    /// @dev Merkle root of the whitelist.\n    bytes32 public merkleRoot;\n\n    /// @dev Mapping from address => total number of tokens a wallet has claimed.\n    mapping(address claimer => uint256 amount) public totalClaimedByWallet;\n\n    /// @dev Emitted when tokens are claimed\n    event TokensClaimed(address indexed claimer, uint256 quantityClaimed);\n\n    /**\n     * @dev Initializes the contract.\n     * @param _tokenOwner The owner of the token to be airdropped.\n     * @param _airdropTokenAddress The address of the token to be airdropped.\n     * @param _airdropAmount The quantity of tokens available for airdrop.\n     * @param _expirationTimestamp Expiration timestamp of the airdrop.\n     * @param _maxWalletClaimCount Maximum number of tokens that can be claimed by a wallet if not in the whitelist.\n     * @param _merkleRoot Merkle root of the whitelist.\n     */\n    constructor(\n        address _tokenOwner,\n        address _airdropTokenAddress,\n        uint256 _airdropAmount,\n        uint256 _expirationTimestamp,\n        uint256 _maxWalletClaimCount,\n        bytes32 _merkleRoot\n    ) {\n        if (_tokenOwner == address(0) || _airdropTokenAddress == address(0) || _airdropAmount == 0) {\n            revert InvalidAirdropParameters(_tokenOwner, _airdropTokenAddress, _airdropAmount);\n        }\n\n        tokenOwner = _tokenOwner;\n        airdropTokenAddress = _airdropTokenAddress;\n        availableAmount = _airdropAmount;\n        expirationTimestamp = _expirationTimestamp;\n        maxWalletClaimCount = _maxWalletClaimCount;\n        merkleRoot = _merkleRoot;\n    }\n\n    /**\n     * @dev Claims tokens from the airdrop.\n     * @param amount The quantity of tokens to claim.\n     * @param proofs Claims proofs.\n     * @param proofMaxQuantityForWallet The maximum quantity of tokens that can be claimed by a wallet.\n     */\n    function claim(uint256 amount, bytes32[] calldata proofs, uint256 proofMaxQuantityForWallet) external {\n        // Verify the claim\n        verifyClaim(msg.sender, amount, proofs, proofMaxQuantityForWallet);\n        // Transfer the claimed tokens\n        _transferClaimedTokens(msg.sender, amount);\n        // Emit the TokensClaimed event\n        emit TokensClaimed(msg.sender, amount);\n    }\n\n    /**\n     * @dev Verifies the claim and reverts if the claim is invalid.\n     * @param claimant The address of the claimer.\n     * @param amount The quantity of tokens to claim.\n     * @param proofs Claims proofs.\n     * @param proofMaxQuantityForWallet The maximum quantity of tokens that can be claimed by a wallet.\n     */\n    function verifyClaim(\n        address claimant,\n        uint256 amount,\n        bytes32[] calldata proofs,\n        uint256 proofMaxQuantityForWallet\n    )\n        public\n        view\n    {\n        bool verified;\n        // Get the proof of the claimer\n        if (merkleRoot != bytes32(0)) {\n            verified =\n                MerkleProof.verify(proofs, merkleRoot, keccak256(abi.encodePacked(claimant, proofMaxQuantityForWallet)));\n        }\n\n        // Check if the wallet has already claimed tokens\n        uint256 supplyClaimedAlready = totalClaimedByWallet[claimant];\n\n        // Check if the claim is valid\n        if (amount == 0 || amount > availableAmount) {\n            revert InvalidTransferAmount();\n        }\n\n        // Check if the airdrop has expired\n        uint256 expTimestamp = expirationTimestamp;\n        if (expTimestamp != 0 && block.timestamp >= expTimestamp) {\n            revert AirdropExpired();\n        }\n\n        // Check if the wallet has exceeded the maximum number of tokens that can be claimed\n        uint256 claimLimitForWallet = verified ? proofMaxQuantityForWallet : maxWalletClaimCount;\n        if (amount + supplyClaimedAlready > claimLimitForWallet) {\n            revert AlreadyClaimedMax();\n        }\n    }\n\n    /**\n     * @dev Transfers the claimed tokens to the recipient.\n     * @param recipient The recipient of the tokens.\n     * @param amount The quantity of tokens to claim.\n     */\n    function _transferClaimedTokens(address recipient, uint256 amount) private {\n        // if transfer claimed tokens is called when `to != msg.sender`, it'd use msg.sender's limits.\n        // behavior would be similar to `msg.sender` mint for itself, then transfer to `_recipient`.\n        totalClaimedByWallet[msg.sender] += amount;\n        availableAmount -= amount;\n\n        IERC20 airdropToken = IERC20(airdropTokenAddress);\n        if (!airdropToken.transfer(recipient, amount)) {\n            revert TransferFailed();\n        }\n        require(airdropToken.transferFrom(tokenOwner, recipient, amount), \"Transfer failed\");\n    }\n}\n"
    },
    "src/AirdropERC20ClaimableFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { AirdropERC20Claimable } from \"./AirdropERC20Claimable.sol\";\n\n/**\n * @title AirdropERC20ClaimableFactory\n * @author @neuro_0x\n * @notice A factory library to deploy instances of the AirdropERC20Claimable contract.\n */\ncontract AirdropERC20ClaimableFactory {\n    /**\n     * @dev Launch a new instance of the CoinGenieAirdropClaimable Contract.\n     * @param tokenOwner The address of the token owner\n     * @param airdropTokenAddress The address of the airdrop token\n     * @param airdropAmount The amount of tokens available for airdrop\n     * @param expirationTimestamp The expiration timestamp of the airdrop\n     * @param maxWalletClaimCount The maximum number of tokens that can be claimed by a wallet if not in the whitelist\n     * @param merkleRoot The merkle root of the whitelist\n     *\n     * @return newAirdrop The address of the newly deployed airdrop contract\n     */\n    function createClaimableAirdrop(\n        address tokenOwner,\n        address airdropTokenAddress,\n        uint256 airdropAmount,\n        uint256 expirationTimestamp,\n        uint256 maxWalletClaimCount,\n        bytes32 merkleRoot\n    )\n        external\n        returns (AirdropERC20Claimable newAirdrop)\n    {\n        AirdropERC20Claimable claimableAirdrop = new AirdropERC20Claimable(\n            tokenOwner,\n            airdropTokenAddress,\n            airdropAmount,\n            expirationTimestamp,\n            maxWalletClaimCount,\n            merkleRoot\n        );\n\n        return claimableAirdrop;\n    }\n}\n"
    },
    "src/CoinGenie.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\nimport { IUniswapV2Pair } from \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport { IUniswapV2Router02 } from \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\nimport { ERC20Factory } from \"./ERC20Factory.sol\";\nimport { AirdropERC20Claimable } from \"./AirdropERC20Claimable.sol\";\nimport { AirdropERC20ClaimableFactory } from \"./AirdropERC20ClaimableFactory.sol\";\nimport { Common } from \"./lib/Common.sol\";\nimport { SafeTransfer } from \"./lib/SafeTransfer.sol\";\n\n/**\n * @title CoinGenie\n * @author @neuro_0x\n * @dev The orchestrator contract for the CoinGenie ecosystem.\n */\ncontract CoinGenie is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    error ShareToHigh(uint256 share, uint256 maxShare);\n\n    error InvalidPayoutCategory(PayoutCategory category);\n\n    uint256 private constant _MAX_BPS = 10_000;\n\n    /// @dev The address of the Uniswap V2 Router. The contract uses the router for liquidity provision and token swaps\n    IUniswapV2Router02 public constant UNISWAP_V2_ROUTER =\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    struct LaunchedToken {\n        address tokenAddress;\n        string name;\n        string symbol;\n        uint256 initialSupply;\n        bool isBurnable;\n        bool isDeflationary;\n        uint256 maxPerWallet;\n        uint256 autoWithdrawThreshold;\n        uint256 maxTaxSwap;\n        address affiliateFeeRecipient;\n        address feeRecipient;\n        uint256 feePercentage;\n        uint256 burnPercentage;\n    }\n\n    struct ClaimableAirdrop {\n        address airdropAddress;\n        address tokenOwner;\n        address airdropTokenAddress;\n        uint256 airdropAmount;\n        uint256 expirationTimestamp;\n        uint256 maxWalletClaimCount;\n        bytes32 merkleRoot;\n    }\n\n    enum PayoutCategory {\n        Treasury,\n        Dev,\n        Legal,\n        Marketing\n    }\n\n    struct Payout {\n        address payable receiver;\n        uint256 share;\n    }\n\n    event ERC20Launched(address indexed newTokenAddress);\n\n    event ClaimableAirdropCreated(\n        address indexed airdropAddress,\n        address tokenOwner,\n        address indexed airdropTokenAddress,\n        uint256 indexed airdropAmount,\n        uint256 expirationTimestamp,\n        uint256 maxWalletClaimCount,\n        bytes32 merkleRoot\n    );\n\n    /// @dev The threshold for the amount of tokens to swap for ETH\n    uint256 public quoteThreshold = 0.1 ether;\n\n    /// @dev A mapping of payout categories to payouts.\n    mapping(PayoutCategory category => Payout payout) private _payouts;\n\n    /// @dev Stores the address of the ERC20Factory contract.\n    ERC20Factory private _erc20Factory;\n\n    /// @dev Stores the address of the AirdropERC20Claimable contract.\n    AirdropERC20ClaimableFactory private _airdropClaimableERC20Factory;\n\n    /// @dev Stores the addresses of all airdrops launched by the contract.\n    address[] public createdClaimableAirdrops;\n\n    /// @dev A mapping of airdrops launched by a specific owner.\n    mapping(address user => ClaimableAirdrop[] airdrops) public claimableAirdropCreatedBy;\n\n    /// @dev Stores the addresses of all tokens launched by the contract.\n    address[] public launchedTokens;\n\n    /// @dev A mapping of tokens launched by a specific owner.\n    mapping(address user => LaunchedToken[] tokens) public tokensLaunchedBy;\n\n    /**\n     * @notice Construct the CoinGenie contract.\n     * @param erc20FactoryAddress The address of the ERC20Factory contract\n     * @param airdropClaimableERC20FactoryAddress The address of the AirdropERC20ClaimableFactory contract\n     */\n    constructor(address erc20FactoryAddress, address airdropClaimableERC20FactoryAddress) {\n        _erc20Factory = ERC20Factory(erc20FactoryAddress);\n        _airdropClaimableERC20Factory = AirdropERC20ClaimableFactory(airdropClaimableERC20FactoryAddress);\n\n        _payouts[PayoutCategory.Treasury] =\n            Payout({ receiver: payable(0xBe79b43B1505290DFE04294a433963dbeea736BB), share: 2000 });\n        _payouts[PayoutCategory.Dev] =\n            Payout({ receiver: payable(0x633Bf832Dc39C0025a7aEaa165ec91ACF02063D5), share: 5000 });\n        _payouts[PayoutCategory.Legal] =\n            Payout({ receiver: payable(0xbb6712A513C2d7F3E17A40d095a773c5d98574B2), share: 1500 });\n        _payouts[PayoutCategory.Marketing] =\n            Payout({ receiver: payable(0xF14A30C09897d2C7481c5907D01Ec58Ec09555af), share: 1500 });\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable { }\n\n    /**\n     * @notice Launch a new instance of the ERC20.\n     * @dev This function deploys a new token contract and initializes it with provided parameters.\n     * @param name The name of the token\n     * @param symbol The symbol of the token\n     * @param initialSupply The initial supply of the token\n     * @param tokenOwner The address that will be the owner of the token\n     * @param customConfigProps A struct of configuration booleans for the token\n     * @param maxPerWallet The maximum amount of tokens allowed to be held by one wallet\n     * @param autoWithdrawThreshold The threshold for the amount of tokens to swap for ETH\n     * @param maxTaxSwap The maximum amount of tokens allowed to be swapped at once by manual or autoswap\n     * @param affiliateFeeRecipient The address to receive the affiliate fee\n     * @param feeRecipient The address to receive the tax fees\n     * @param feePercentage The percent in basis points to use as a tax\n     * @param burnPercentage The percent in basis points to burn on every tx if this token is deflationary\n     *\n     * @return _tokenAddress The address of the newly deployed token contract\n     */\n    function launchToken(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address tokenOwner,\n        Common.TokenConfigProperties memory customConfigProps,\n        uint256 maxPerWallet,\n        uint256 autoWithdrawThreshold,\n        uint256 maxTaxSwap,\n        address affiliateFeeRecipient,\n        address feeRecipient,\n        uint256 feePercentage,\n        uint256 burnPercentage\n    )\n        external\n        returns (address)\n    {\n        // Deploy the token contract\n        IERC20 newToken = _erc20Factory.launchToken(\n            name,\n            symbol,\n            initialSupply,\n            tokenOwner,\n            customConfigProps,\n            maxPerWallet,\n            autoWithdrawThreshold,\n            maxTaxSwap,\n            affiliateFeeRecipient,\n            feeRecipient,\n            feePercentage,\n            burnPercentage,\n            address(this)\n        );\n\n        address newTokenAddress = address(newToken);\n\n        // Add the token address to the array of launched tokens\n        launchedTokens.push(newTokenAddress);\n        // Add the token address to the mapping of tokens launched by a specific owner\n        tokensLaunchedBy[tokenOwner].push(\n            LaunchedToken({\n                tokenAddress: newTokenAddress,\n                name: name,\n                symbol: symbol,\n                initialSupply: initialSupply,\n                isBurnable: customConfigProps.isBurnable,\n                isDeflationary: customConfigProps.isDeflationary,\n                maxPerWallet: maxPerWallet,\n                autoWithdrawThreshold: autoWithdrawThreshold,\n                maxTaxSwap: maxTaxSwap,\n                affiliateFeeRecipient: affiliateFeeRecipient,\n                feeRecipient: feeRecipient,\n                feePercentage: feePercentage,\n                burnPercentage: burnPercentage\n            })\n        );\n\n        // Emit the event\n        emit ERC20Launched(newTokenAddress);\n\n        return newTokenAddress;\n    }\n\n    /**\n     * @notice Launch a new instance of the CoinGenieAirdropClaimable Contract.\n     * @param tokenOwner The address of the token owner\n     * @param airdropTokenAddress The address of the airdrop token\n     * @param airdropAmount The amount of tokens available for airdrop\n     * @param expirationTimestamp The expiration timestamp of the airdrop\n     * @param maxWalletClaimCount The maximum number of tokens that can be claimed by a wallet if not in the whitelist\n     * @param merkleRoot The merkle root of the whitelist\n     *\n     * @return dropAddress The address of the newly deployed airdrop contract\n     */\n    function createClaimableAirdrop(\n        address tokenOwner,\n        address airdropTokenAddress,\n        uint256 airdropAmount,\n        uint256 expirationTimestamp,\n        uint256 maxWalletClaimCount,\n        bytes32 merkleRoot\n    )\n        external\n        returns (address dropAddress)\n    {\n        // Deploy the airdrop contract\n        AirdropERC20Claimable airdrop = _airdropClaimableERC20Factory.createClaimableAirdrop(\n            tokenOwner, airdropTokenAddress, airdropAmount, expirationTimestamp, maxWalletClaimCount, merkleRoot\n        );\n\n        // Add the airdrop address to the array of created airdrops\n        createdClaimableAirdrops.push(address(airdrop));\n\n        // Add the airdrop details to the mapping of airdrops created by a specific owner\n        ClaimableAirdrop memory claimableAirdrop = ClaimableAirdrop({\n            airdropAddress: address(airdrop),\n            tokenOwner: tokenOwner,\n            airdropTokenAddress: airdropTokenAddress,\n            airdropAmount: airdropAmount,\n            expirationTimestamp: expirationTimestamp,\n            maxWalletClaimCount: maxWalletClaimCount,\n            merkleRoot: merkleRoot\n        });\n        claimableAirdropCreatedBy[msg.sender].push(claimableAirdrop);\n\n        // Emit the event\n        emit ClaimableAirdropCreated(\n            address(airdrop),\n            tokenOwner,\n            airdropTokenAddress,\n            airdropAmount,\n            expirationTimestamp,\n            maxWalletClaimCount,\n            merkleRoot\n        );\n\n        return address(airdrop);\n    }\n\n    /**\n     * @notice Get the payout address for a specific category.\n     * @param category The category to get the payout address for\n     * @return receiver The address to receive the payout\n     */\n    function getPayoutAddress(PayoutCategory category) external view returns (address payable) {\n        return _payouts[category].receiver;\n    }\n\n    /**\n     * @notice Get the payout share for a specific category.\n     * @param category The category to get the payout share for\n     * @return share The share of the payout\n     */\n    function getPayoutShare(PayoutCategory category) external view returns (uint256) {\n        return _payouts[category].share;\n    }\n\n    /**\n     * @notice Set the payout address for a specific category.\n     * @param category The category to set the payout address for\n     * @param receiver The address to receive the payout\n     * @param share The share of the payout\n     */\n    function updatePayout(PayoutCategory category, address payable receiver, uint256 share) external onlyOwner {\n        if (share > _payouts[category].share) {\n            revert ShareToHigh(share, _payouts[category].share);\n        }\n\n        if (category > PayoutCategory.Marketing) {\n            revert InvalidPayoutCategory(category);\n        }\n\n        _payouts[category] = Payout({ receiver: receiver, share: share });\n    }\n\n    /**\n     * @notice Withdraw the contract balance to the payout addresses.\n     */\n    function withdraw() external {\n        uint256 contractBalance = address(this).balance;\n\n        uint256 treasuryShare = _payouts[PayoutCategory.Treasury].share;\n        uint256 devShare = _payouts[PayoutCategory.Dev].share;\n        uint256 legalShare = _payouts[PayoutCategory.Legal].share;\n        uint256 marketingShare = _payouts[PayoutCategory.Marketing].share;\n\n        uint256 treasuryAmount = contractBalance.mul(treasuryShare).div(_MAX_BPS);\n        uint256 devAmount = contractBalance.mul(devShare).div(_MAX_BPS);\n        uint256 legalAmount = contractBalance.mul(legalShare).div(_MAX_BPS);\n        uint256 marketingAmount = contractBalance.mul(marketingShare).div(_MAX_BPS);\n\n        SafeTransfer.safeTransferETH(_payouts[PayoutCategory.Treasury].receiver, treasuryAmount);\n        SafeTransfer.safeTransferETH(_payouts[PayoutCategory.Dev].receiver, devAmount);\n        SafeTransfer.safeTransferETH(_payouts[PayoutCategory.Legal].receiver, legalAmount);\n        SafeTransfer.safeTransferETH(_payouts[PayoutCategory.Marketing].receiver, marketingAmount);\n    }\n\n    /**\n     * @notice Swap ERC20 tokens for ETH.\n     * @param tokenAddress The address of the token to swap\n     * @param amount The amount of tokens to swap\n     */\n    function swapERC20s(address tokenAddress, address lpTokenAddress, uint256 amount) external {\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(lpTokenAddress).getReserves();\n        uint256 quotedAmount = UNISWAP_V2_ROUTER.quote(amount, reserve0, reserve1);\n\n        if (quotedAmount >= quoteThreshold) {\n            require(IERC20(tokenAddress).approve(address(UNISWAP_V2_ROUTER), amount), \"Approval failed\");\n\n            address[] memory path = new address[](2);\n            path[0] = tokenAddress;\n            path[1] = UNISWAP_V2_ROUTER.WETH();\n\n            UNISWAP_V2_ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                amount,\n                0, // accept any amount of ETH\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n    }\n\n    /**\n     * @notice Set the threshold for the amount of tokens to swap for ETH.\n     * @param _quoteThreshold The threshold for the amount of tokens to swap for ETH\n     */\n    function setQuoteThreshold(uint256 _quoteThreshold) external onlyOwner {\n        quoteThreshold = _quoteThreshold;\n    }\n\n    /**\n     * @notice Get the launched tokens.\n     * @param _address The address to get the tokens for\n     * @return tokens The array of launched tokens\n     */\n    function getLaunchedTokensForAddress(address _address) external view returns (LaunchedToken[] memory tokens) {\n        return tokensLaunchedBy[_address];\n    }\n\n    /**\n     * @notice Get the airdrops created by a specific address.\n     * @param _address The address to get the airdrops for\n     */\n    function getClaimableAirdropsForAddress(address _address)\n        external\n        view\n        returns (ClaimableAirdrop[] memory airdrops)\n    {\n        return claimableAirdropCreatedBy[_address];\n    }\n}\n"
    },
    "src/CoinGenieERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.20;\n\nimport { ERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ERC20Burnable } from \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { ERC20Pausable } from \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport { SafeMath } from \"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\nimport { IUniswapV2Pair } from \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport { IUniswapV2Router02 } from \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport { IUniswapV2Factory } from \"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\n\nimport { Common } from \"./lib/Common.sol\";\nimport { SafeTransfer } from \"./lib/SafeTransfer.sol\";\n\n/**\n * @title CoinGenieERC20\n * @author @neuro_0x\n * @notice A robust and secure ERC20 token for the Coin Genie ecosystem\n *\n * @notice THIS ERC20 SHOULD ONLY BE DEPLOYED FROM THE COINGENIE ERC20 FACTORY\n */\ncontract CoinGenieERC20 is ERC20, ERC20Burnable, ERC20Pausable, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    /**\n     * Private constants\n     */\n\n    /// @dev The max basis points representing 100%\n    uint256 private constant _MAX_BPS = 10_000;\n\n    /// @dev The max tax that can be applied to a transaction. The value is in ether but is handled as 5%.\n    uint256 private constant _MAX_TAX = 2000; // 20%\n\n    /// @dev The minimum amount of eth that must be added to Uniswap when trading is opened.\n    uint256 private constant _MIN_LIQUIDITY_ETH = 0.5 ether;\n\n    /// @dev The minimum amount of erc20 token that must be added to Uniswap when trading is opened.\n    uint256 private constant _MIN_LIQUIDITY_TOKEN = 1 ether;\n\n    /// @dev the royalty fee percentage taken on transfers\n    uint256 private constant _TREASURY_FEE_PERCENTAGE = 50; // 0.5%;\n\n    /// @dev the percent of eth taken when liquidity is open\n    uint256 private constant _LP_ETH_FEE_PERCENTAGE = 50; // 0.5%;\n\n    /// @dev the affiliate fee percentage taken on transfers\n    uint256 private constant _AFFILIATE_FEE_PERCENTAGE = 25; // 0.25%;\n\n    /**\n     * Private immutable\n     */\n\n    /// @dev number of decimals of the token\n    uint8 private immutable _tokenDecimals;\n\n    address private immutable _initialTokenOwner;\n\n    /**\n     * Private constants\n     */\n\n    /// @dev Are we currently swapping tokens for ETH?\n    bool private _inSwap;\n\n    /// @dev The whitelist of addresses that are exempt from fees\n    mapping(address feePayer => bool isWhitelisted) private _feeWhitelist;\n\n    /**\n     * Public constants\n     */\n\n    /// @dev The address of the Uniswap V2 Router. The contract uses the router for liquidity provision and token swaps\n    IUniswapV2Router02 public constant UNISWAP_V2_ROUTER =\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    /**\n     * Public immutable\n     */\n\n    /// @dev initial number of tokens which will be minted during initialization\n    uint256 public immutable initialSupply;\n\n    /// @dev address of the affiliate fee recipient\n    address public immutable affiliateFeeRecipient;\n\n    /**\n     * Public\n     */\n\n    /// @dev The amount of $GENIE a person has to hold to get the discount\n    uint256 public discountFeeRequiredAmount = 1_000_000 ether;\n\n    /// @dev The address of the genie token\n    address public genieToken;\n\n    /// @dev max amount of tokens allowed per wallet\n    uint256 public maxTokenAmountPerAddress;\n\n    /// @dev max amount of tokens the contract can accrue before swapping them for ETH\n    uint256 public maxTaxSwap;\n\n    /// @dev max amount of ETH the contract can accrue before withdrawing them to the fee recipient\n    uint256 public autoWithdrawThreshold;\n\n    /// @dev features of the token\n    Common.TokenConfigProperties public tokenConfig;\n\n    /// @dev the address of the fee recipient\n    address public feeRecipient;\n\n    /// @dev address of the royalty fee recipient (Coin Genie)\n    address public treasuryRecipient;\n\n    /// @dev the fee percentage in basis points\n    uint256 public feePercentage;\n\n    /// @dev the affiliate fee percentage in basis points\n    uint256 public burnPercentage;\n\n    /// @dev The address of the LP token. The contract uses the LP token to determine if a transfer is a buy or sell\n    address public uniswapV2Pair;\n\n    /// @dev The flag for whether swapping is enabled and trading open\n    bool public isSwapEnabled;\n\n    /// @dev Modifier to prevent swapping tokens for ETH recursively\n    modifier lockTheSwap() {\n        _inSwap = true;\n        _;\n        _inSwap = false;\n    }\n\n    /// @notice Error thrown when the genie is already set.\n    error GenieAlreadySet();\n\n    /// @notice Error thrown when the provided maximum token amount is invalid.\n    error InvalidMaxTokenAmount(uint256 maxPerWallet);\n\n    /// @notice Error thrown when the new maximum token amount per address is less than or equal to the previous value.\n    error MaxTokenAmountPerAddrLtPrevious();\n\n    /// @notice Error thrown when the destination balance exceeds the maximum allowed amount.\n    /// @param addr The address whose balance would exceed the limit.\n    error DestBalanceExceedsMaxAllowed(address addr);\n\n    /// @notice Error thrown when burning is not enabled.\n    error BurningNotEnabled();\n\n    /// @notice Error thrown when pausing is not enabled.\n    error PausingNotEnabled();\n\n    /// @notice Error thrown when the token is not deflationary.\n    error TokenIsNotDeflationary();\n\n    /// @notice Error thrown when an invalid tax basis point is provided.\n    /// @param bps The invalid basis points for tax.\n    error InvalidTaxBPS(uint256 bps);\n\n    /// @notice Error thrown when an invalid deflation basis point is provided.\n    /// @param bps The invalid basis points for deflation.\n    error InvalidDeflationBPS(uint256 bps);\n\n    /// @notice Error thrown when trading is already open.\n    error TradingAlreadyOpen();\n\n    /// @notice Error thrown when the someone other than initial owner tries to manual swap tokens.\n    error OnlyInitialOwner();\n\n    /// @notice Error thrown when the provided ETH amount is insufficient.\n    /// @param amount The provided ETH amount.\n    /// @param minAmount The minimum required ETH amount.\n    error InsufficientETH(uint256 amount, uint256 minAmount);\n\n    /// @notice Error thrown when the provided token amount is insufficient.\n    /// @param amount The provided token amount.\n    /// @param minAmount The minimum required token amount.\n    error InsufficientTokens(uint256 amount, uint256 minAmount);\n\n    /// @notice This event is emitted when the trading is opened.\n    /// @param pair The address of the LP token.\n    event TradingOpened(address indexed pair);\n\n    /// @notice This event is emitted when the maximum number of tokens allowed per wallet has been updated.\n    /// @param newMaxTokenAmount The new maximum token amount per wallet.\n    event MaxTokensPerWalletSet(uint256 indexed newMaxTokenAmount);\n\n    /// @notice This event is emitted when the fee configuration of the token has been updated.\n    /// @param _feeRecipient The updated fee recipient address.\n    /// @param _feePercentage The updated fee percentage.\n    event FeeConfigUpdated(address indexed _feeRecipient, uint256 indexed _feePercentage);\n\n    /// @notice This event is emitted when the burn configuration of the token has been updated.\n    /// @param _burnPercentage The updated burn percentage.\n    event BurnConfigUpdated(uint256 indexed _burnPercentage);\n\n    /// @notice This event is emitted when the maximum amount of tokens to swap for tax has been updated.\n    /// @param maxTaxSwap The updated maximum amount of tokens to swap for tax.\n    event MaxTaxSwapUpdated(uint256 indexed maxTaxSwap);\n\n    /// @notice This event is emitted when the auto withdraw threshold has been updated.\n    /// @param threshold The updated auto withdraw threshold.\n    event AutoWithdrawThresholdUpdated(uint256 indexed threshold);\n\n    /**\n     * @dev Initializes the contract with the provided parameters\n     * @param name_ The name of the token\n     * @param symbol_ The symbol of the token\n     * @param initialSupplyToSet The initial supply of the token\n     * @param tokenOwner The owner of the token\n     * @param customConfigProps Represents the features of the token\n     * @param maxPerWallet The max amount of tokens per wallet\n     * @param maxToSwapForTax The max amount of tokens to swap for tax\n     * @param _affilateFeeRecipient The address of the affiliate fee recipient\n     * @param _feeRecipient The address of the fee recipient\n     * @param _feePercentage The fee percentage in basis points\n     * @param _burnPercentage The burn percentage in basis points\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 initialSupplyToSet,\n        address tokenOwner,\n        Common.TokenConfigProperties memory customConfigProps,\n        uint256 maxPerWallet,\n        uint256 maxToSwapForTax,\n        uint256 _autoWithdrawThreshold,\n        address _affilateFeeRecipient,\n        address _feeRecipient,\n        uint256 _feePercentage,\n        uint256 _burnPercentage\n    )\n        ERC20(name_, symbol_)\n    {\n        SafeTransfer.validateAddress(tokenOwner);\n        initialSupply = initialSupplyToSet;\n        _tokenDecimals = 18;\n        affiliateFeeRecipient = _affilateFeeRecipient;\n\n        if (_feePercentage > _MAX_TAX) {\n            revert InvalidTaxBPS(_feePercentage);\n        }\n\n        if (customConfigProps.isDeflationary) {\n            if (_burnPercentage > _MAX_TAX) {\n                revert InvalidDeflationBPS(_burnPercentage);\n            }\n\n            burnPercentage = _burnPercentage;\n        }\n\n        tokenConfig = customConfigProps;\n        maxTokenAmountPerAddress = maxPerWallet;\n        maxTaxSwap = maxToSwapForTax;\n        autoWithdrawThreshold = _autoWithdrawThreshold;\n        _initialTokenOwner = tokenOwner;\n\n        SafeTransfer.validateAddress(_feeRecipient);\n        feeRecipient = _feeRecipient;\n        feePercentage = _feePercentage;\n\n        if (initialSupplyToSet != 0) {\n            _mint(tokenOwner, initialSupplyToSet);\n        }\n\n        _feeWhitelist[address(this)] = true;\n        _feeWhitelist[tokenOwner] = true;\n        _feeWhitelist[feeRecipient] = true;\n        _feeWhitelist[treasuryRecipient] = true;\n\n        if (affiliateFeeRecipient != address(0)) {\n            _feeWhitelist[affiliateFeeRecipient] = true;\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable { }\n\n    /**\n     * @return true if the token is pausable\n     */\n    function isPausable() public view returns (bool) {\n        return tokenConfig.isPausable;\n    }\n\n    /**\n     * @return true if the token is burnable\n     */\n    function isBurnable() public view returns (bool) {\n        return tokenConfig.isBurnable;\n    }\n\n    /**\n     * @return true if the feePayer is whitelisted\n     */\n    function isWhitelisted(address feePayer) public view returns (bool) {\n        return _feeWhitelist[feePayer];\n    }\n\n    /**\n     * @return number of decimals for the token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _tokenDecimals;\n    }\n\n    /**\n     * @return true if the token supports deflation\n     */\n    function isDeflationary() public view returns (bool) {\n        return tokenConfig.isDeflationary;\n    }\n\n    /**\n     * @dev Allows the owner to set the address of the coingenie\n     * @param coinGenieAddress - the address of the coinGenie\n     */\n    function setCoinGenieTreasury(address coinGenieAddress) external {\n        if (treasuryRecipient != address(0)) {\n            revert GenieAlreadySet();\n        }\n\n        treasuryRecipient = coinGenieAddress;\n    }\n\n    /**\n     * @dev Allows the owner to set the max amount of tokens the contract can accrue before swapping them for ETH\n     * @param maxTax - the new max amount of tokens to swap for tax\n     */\n    function setMaxTaxSwap(uint256 maxTax) external onlyOwner {\n        maxTaxSwap = maxTax;\n        emit MaxTaxSwapUpdated(maxTax);\n    }\n\n    /**\n     * @dev Allows the owner to set the max amount of tokens the contract can accrue before swapping them for ETH\n     * @param threshold - the new max amount of tokens to swap for tax\n     */\n    function setAutoWithdrawThreshold(uint256 threshold) external onlyOwner {\n        autoWithdrawThreshold = threshold;\n        emit AutoWithdrawThresholdUpdated(threshold);\n    }\n\n    /**\n     * @dev Allows the owner to set a max amount of tokens per wallet\n     * @param newMaxTokenAmount - the new max amount of tokens per wallet\n     *\n     * @notice only callable by the owner\n     * @notice only callable if the token is not paused\n     * @notice only callable if the token supports max amount of tokens per wallet\n     */\n    function setMaxTokenAmountPerAddress(uint256 newMaxTokenAmount) external onlyOwner whenNotPaused {\n        if (newMaxTokenAmount <= maxTokenAmountPerAddress) {\n            revert MaxTokenAmountPerAddrLtPrevious();\n        }\n\n        maxTokenAmountPerAddress = newMaxTokenAmount;\n        emit MaxTokensPerWalletSet(newMaxTokenAmount);\n    }\n\n    /**\n     * @dev Allows the owner to set the tax config\n     * @param _feeRecipient - the new feeRecipient\n     * @param _feePercentage - the new feePercentage\n     *\n     * @notice only callable by the owner\n     * @notice only callable if the token is not paused\n     * @notice only callable if the feePercentage is not greater than the max tax\n     */\n    function setTaxConfig(address _feeRecipient, uint256 _feePercentage) external onlyOwner whenNotPaused {\n        if (_feePercentage > _MAX_TAX) {\n            revert InvalidTaxBPS(_feePercentage);\n        }\n\n        feePercentage = _feePercentage;\n\n        SafeTransfer.validateAddress(_feeRecipient);\n        _feeWhitelist[feeRecipient] = false;\n        feeRecipient = _feeRecipient;\n        _feeWhitelist[feeRecipient] = true;\n\n        emit FeeConfigUpdated(_feeRecipient, _feePercentage);\n    }\n\n    /**\n     * @dev Allows the owner to set the deflation config\n     * @param _burnPercentage - the new burnPercentage\n     *\n     * @notice only callable by the owner\n     * @notice only callable if the token is not paused\n     * @notice only callable if the token supports deflation\n     * @notice only callable if the burnPercentage is not greater than the max allowed bps\n     */\n    function setDeflationConfig(uint256 _burnPercentage) external onlyOwner whenNotPaused {\n        if (!isDeflationary()) {\n            revert TokenIsNotDeflationary();\n        }\n\n        if (_burnPercentage > _MAX_TAX) {\n            revert InvalidDeflationBPS(_burnPercentage);\n        }\n\n        burnPercentage = _burnPercentage;\n        emit BurnConfigUpdated(_burnPercentage);\n    }\n\n    /**\n     * @dev Allows to transfer a predefined amount of tokens to a predefined address\n     * @param to - the address to transfer the tokens to\n     * @param amount - the amount of tokens to transfer\n     * @return true if the transfer was successful\n     *\n     * @notice only callable if the token is not paused\n     * @notice only callable if the balance of the receiver is lower than the max amount of tokens per wallet\n     * @notice checks if blacklisting is enabled and if the sender and receiver are not blacklisted\n     * @notice checks if whitelisting is enabled and if the sender and receiver are whitelisted\n     * @notice captures the tax during the transfer if tax is enabvled\n     * @notice burns the deflationary amount during the transfer if deflation is enabled\n     */\n    function transfer(address to, uint256 amount) public virtual override whenNotPaused returns (bool) {\n        address from = msg.sender;\n        bool excludedFromFee = _feeWhitelist[from] || _feeWhitelist[to];\n\n        if (isSwapEnabled && !excludedFromFee) {\n            uint256 amountToTransfer = _takeFees(from, to, amount);\n\n            return super.transfer(to, amountToTransfer);\n        }\n\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @dev Allows to transfer a predefined amount of tokens from a predefined address to a predefined address\n     * @param from - the address to transfer the tokens from\n     * @param to - the address to transfer the tokens to\n     * @param amount - the amount of tokens to transfer\n     * @return true if the transfer was successful\n     *\n     * @notice only callable if the token is not paused\n     * @notice only callable if the balance of the receiver is lower than the max amount of tokens per wallet\n     * @notice checks if blacklisting is enabled and if the sender and receiver are not blacklisted\n     * @notice checks if whitelisting is enabled and if the sender and receiver are whitelisted\n     * @notice captures the tax during the transfer if tax is enabvled\n     * @notice burns the deflationary amount during the transfer if deflation is enabled\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        bool excludedFromFee = _feeWhitelist[from] || _feeWhitelist[to];\n\n        if (isSwapEnabled && !excludedFromFee) {\n            uint256 amountToTransfer = _takeFees(from, to, amount);\n\n            return super.transferFrom(from, to, amountToTransfer);\n        }\n\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Allows to burn a predefined amount of tokens\n     * @param amount - the amount of tokens to burn\n     *\n     * @notice only callable by the owner\n     * @notice only callable if the token is not paused\n     * @notice only callable if the token supports burning\n     */\n    function burn(uint256 amount) public override onlyOwner whenNotPaused {\n        if (!isBurnable()) {\n            revert BurningNotEnabled();\n        }\n\n        super.burn(amount);\n    }\n\n    /**\n     * @dev Allows to burn a predefined amount of tokens from a predefined address\n     * @param from - the address to burn the tokens from\n     * @param amount - the amount of tokens to burn\n     *\n     * @notice only callable by the owner\n     * @notice only callable if the token is not paused\n     * @notice only callable if the token supports burning\n     * @notice needs Approval\n     */\n    function burnFrom(address from, uint256 amount) public override onlyOwner whenNotPaused {\n        if (!isBurnable()) {\n            revert BurningNotEnabled();\n        }\n\n        super.burnFrom(from, amount);\n    }\n\n    /**\n     * @dev Allows to pause the token\n     *\n     * @notice only callable by the owner\n     */\n    function pause() external onlyOwner {\n        if (!isPausable()) {\n            revert PausingNotEnabled();\n        }\n        _pause();\n    }\n\n    /**\n     * @dev Allows to unpause the token\n     *\n     * @notice only callable by the owner\n     */\n    function unpause() external onlyOwner {\n        if (!isPausable()) {\n            revert PausingNotEnabled();\n        }\n        _unpause();\n    }\n\n    /**\n     * @dev Opens trading for the token by adding liquidity to Uniswap.\n     * @param amountToLP The amount of tokens to add to Uniswap\n     *\n     * Emits a {TradingOpened} event.\n     *\n     * Preconditions:\n     *\n     * Requirements:\n     *\n     * `isSwapEnabled` must be false.\n     * `amountToLP >= _MIN_LIQUIDITY_TOKEN`\n     * `msg.value >= _MIN_LIQUIDITY_ETH`\n     */\n    function openTrading(uint256 amountToLP) external payable onlyOwner nonReentrant returns (IUniswapV2Pair) {\n        uint256 value = msg.value;\n        if (isSwapEnabled) {\n            revert TradingAlreadyOpen();\n        }\n\n        if (amountToLP < _MIN_LIQUIDITY_TOKEN || balanceOf(owner()) < amountToLP) {\n            revert InsufficientTokens(amountToLP, _MIN_LIQUIDITY_TOKEN);\n        }\n\n        if (value < _MIN_LIQUIDITY_ETH) {\n            revert InsufficientETH(value, _MIN_LIQUIDITY_ETH);\n        }\n\n        // Transfer the tokens to the contract\n        transfer(address(this), amountToLP);\n\n        // Get the ETH amount to LP and the ETH amount to treasury\n        uint256 genieBalance = IERC20(genieToken).balanceOf(address(this));\n        uint256 ethAmountToTreasury = value.mul(_LP_ETH_FEE_PERCENTAGE).div(_MAX_BPS);\n\n        // If the genie balance is greater than the required amount, the fee is free\n        if (genieBalance > discountFeeRequiredAmount) {\n            ethAmountToTreasury = 0;\n        }\n\n        uint256 ethAmountToLP = value.sub(ethAmountToTreasury);\n\n        // Approve the router to spend the tokens\n        _approve(address(this), address(UNISWAP_V2_ROUTER), totalSupply());\n\n        // Create the LP token\n        uniswapV2Pair =\n            IUniswapV2Factory(UNISWAP_V2_ROUTER.factory()).createPair(address(this), UNISWAP_V2_ROUTER.WETH());\n\n        // Approve the router to spend the LP token\n        IERC20(uniswapV2Pair).approve(address(UNISWAP_V2_ROUTER), type(uint256).max);\n\n        // Add liquidity to Uniswap\n        UNISWAP_V2_ROUTER.addLiquidityETH{ value: ethAmountToLP }(\n            address(this), balanceOf(address(this)), 0, 0, owner(), block.timestamp\n        );\n\n        // Enable swapping\n        isSwapEnabled = true;\n\n        // Send fee to the treasury\n        if (ethAmountToTreasury > 0) {\n            payable(treasuryRecipient).transfer(ethAmountToTreasury);\n        }\n\n        emit TradingOpened(uniswapV2Pair);\n\n        return IUniswapV2Pair(uniswapV2Pair);\n    }\n\n    /**\n     * @dev Sets the address of the genie token\n     * @param genie - the address of the genie token\n     */\n    function setGenie(address genie) external onlyOwner {\n        if (genieToken != address(0)) {\n            revert GenieAlreadySet();\n        }\n\n        genieToken = genie;\n    }\n\n    /**\n     * @dev Swaps tokens for ETH if the contract balance is greater than the max amount to swap for tax. Then sends\n     * the ETH to the tax wallet.\n     *\n     * @notice only callable by the initial owner of the token contract. This is done so that you can still easily swap\n     * using Coin Genie.\n     */\n    function manualSwap() external nonReentrant {\n        address from = msg.sender;\n        uint256 tokenBalance = balanceOf(from);\n\n        if (from != _initialTokenOwner) {\n            revert OnlyInitialOwner();\n        }\n\n        if (tokenBalance > 0) {\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = UNISWAP_V2_ROUTER.WETH();\n            _approve(from, address(UNISWAP_V2_ROUTER), tokenBalance);\n            UNISWAP_V2_ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\n                tokenBalance, 0, path, from, block.timestamp\n            );\n        }\n    }\n\n    /**\n     * @dev hook called before any transfer of tokens. This includes minting and burning\n     * imposed by the ERC20 standard\n     * @param from - address of the sender\n     * @param to - address of the recipient\n     * @param amount - amount of tokens to transfer\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        virtual\n        override(ERC20, ERC20Pausable)\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _takeFees(address from, address to, uint256 amount) private returns (uint256 _amount) {\n        uint256 treasuryAmount;\n        uint256 taxAmount;\n        uint256 affiliateAmount;\n        uint256 deflationAmount;\n\n        if (treasuryRecipient != address(0) && _TREASURY_FEE_PERCENTAGE != 0) {\n            treasuryAmount = amount.mul(_TREASURY_FEE_PERCENTAGE).div(_MAX_BPS);\n        }\n\n        if (feeRecipient != address(0) && feePercentage != 0) {\n            taxAmount = amount.mul(feePercentage).div(_MAX_BPS);\n        }\n\n        if (affiliateFeeRecipient != address(0) && _AFFILIATE_FEE_PERCENTAGE != 0) {\n            affiliateAmount = amount.mul(_AFFILIATE_FEE_PERCENTAGE).div(_MAX_BPS);\n        }\n\n        if (isDeflationary()) {\n            deflationAmount = amount.mul(burnPercentage).div(_MAX_BPS);\n        }\n\n        _amount = amount.sub(treasuryAmount).sub(taxAmount).sub(affiliateAmount).sub(deflationAmount);\n        bool exceedsMaxAmountIsBuy = from == uniswapV2Pair && to != address(UNISWAP_V2_ROUTER)\n            && balanceOf(to) + _amount > maxTokenAmountPerAddress;\n\n        if (exceedsMaxAmountIsBuy) {\n            revert DestBalanceExceedsMaxAllowed(to);\n        }\n\n        if (treasuryAmount != 0) {\n            _transfer(from, treasuryRecipient, treasuryAmount);\n        }\n\n        if (affiliateAmount != 0) {\n            _transfer(from, affiliateFeeRecipient, affiliateAmount);\n        }\n\n        if (taxAmount != 0) {\n            _transfer(from, feeRecipient, taxAmount);\n        }\n\n        if (deflationAmount != 0) {\n            _burn(from, deflationAmount);\n        }\n\n        return _amount;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     * @param a The first number.\n     * @param b The second number.\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "src/ERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\nimport { CoinGenieERC20 } from \"./CoinGenieERC20.sol\";\nimport { Common } from \"./lib/Common.sol\";\n\n/**\n * @title ERC20Factory\n * @author @neuro_0x\n * @dev A factory library to deploy instances of the CoinGenieERC20 contract.\n */\ncontract ERC20Factory is Ownable {\n    /// @dev The address of the genie token\n    address private _genie;\n\n    /// @notice Error thrown when the genie is already set.\n    error GenieAlreadySet();\n\n    /**\n     * @dev Creates a new instance of the CoinGenieERC20 contract\n     * @param name - the name of the token\n     * @param symbol - the ticker symbol of the token\n     * @param initialSupply - the initial supply of the token\n     * @param tokenOwner - the address that will be the owner of the token\n     * @param customConfigProps - a struct of configuration booleans for the token\n     * @param maxPerWallet - the maximum amount of tokens allowed to be held by one wallet\n     * @param maxTaxSwap - the maximum amount of tokens allowed to be swapped at once by manual or autoswap\n     * @param autoWithdrawThreshold - the threshold at which the contract will automatically withdraw the tax fees\n     * @param affilateFeeRecipient - the address to receive the affiliate fee\n     * @param feeRecipient - the address to receive the tax fees\n     * @param feePercentage - the percent in basis points to use as a tax\n     * @param burnPercentage - the percent in basis points to burn on every tx if this token is deflationary\n     * @param treasuryRecipient - the address to receive the royalty fee\n     *\n     * @return newToken - the CoinGenieERC20 token that was created\n     */\n    function launchToken(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address tokenOwner,\n        Common.TokenConfigProperties memory customConfigProps,\n        uint256 maxPerWallet,\n        uint256 autoWithdrawThreshold,\n        uint256 maxTaxSwap,\n        address affilateFeeRecipient,\n        address feeRecipient,\n        uint256 feePercentage,\n        uint256 burnPercentage,\n        address treasuryRecipient\n    )\n        external\n        returns (CoinGenieERC20 newToken)\n    {\n        CoinGenieERC20 coinGenieERC20 = new CoinGenieERC20(\n            name,\n            symbol,\n            initialSupply,\n            tokenOwner,\n            customConfigProps,\n            maxPerWallet,\n            maxTaxSwap,\n            autoWithdrawThreshold,\n            affilateFeeRecipient,\n            feeRecipient,\n            feePercentage,\n            burnPercentage\n        );\n\n        coinGenieERC20.setCoinGenieTreasury(treasuryRecipient);\n        coinGenieERC20.setGenie(_genie);\n\n        if (tokenOwner != address(0) && tokenOwner != coinGenieERC20.owner()) {\n            coinGenieERC20.transferOwnership(tokenOwner);\n        }\n\n        return coinGenieERC20;\n    }\n\n    /**\n     * @dev Sets the address of the genie token\n     * @param genie - the address of the genie token\n     */\n    function setGenie(address genie) external onlyOwner {\n        if (_genie != address(0)) {\n            revert GenieAlreadySet();\n        }\n\n        _genie = genie;\n    }\n}\n"
    },
    "src/lib/Common.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\n/**\n * @title Common\n * @dev Common items used across the CoinGenie contracts.\n */\nlibrary Common {\n    /// @dev set of features supported by the token\n    struct TokenConfigProperties {\n        bool isBurnable;\n        bool isPausable;\n        bool isDeflationary;\n    }\n}\n"
    },
    "src/lib/SafeTransfer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nlibrary SafeTransfer {\n    error TransferFailed();\n\n    /**\n     * @dev Sends `amount` (in wei) ETH to `to`.\n     * @param to The address to send the ETH to.\n     * @param amount The amount of ETH to send.\n     */\n    function safeTransferETH(address to, uint256 amount) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                // bytes4(keccak256(bytes(\"ETHTransferFailed()\"))) = 0xb12d13eb\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Validates that the address is not the zero address using assembly.\n     * @dev Reverts if the address is the zero address.\n     * @param addr The address to validate.\n     */\n    function validateAddress(address addr) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            if iszero(shl(96, addr)) {\n                // Store the function selector of `ZeroAddress()`.\n                // bytes4(keccak256(bytes(\"ZeroAddress()\"))) = 0xd92e233d\n                mstore(0x00, 0xd92e233d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function to transfer ERC20 tokens without the need for SafeERC20.\n     * @dev Reverts if the ERC20 transfer fails.\n     * @param tokenAddress The address of the ERC20 token.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the tokens to.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(address tokenAddress, address from, address to, uint256 amount) internal returns (bool) {\n        (bool success, bytes memory data) =\n        // solhint-disable-next-line avoid-low-level-calls\n         tokenAddress.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, amount));\n        if (!success) {\n            if (data.length != 0) {\n                // bubble up error\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(data)\n                    revert(add(32, data), returndata_size)\n                }\n            } else {\n                revert TransferFailed();\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Helper function to transfer ERC20 tokens without the need for SafeERC20.\n    /// @dev Reverts if the ERC20 transfer fails.\n    /// @param tokenAddress The address of the ERC20 token.\n    /// @param to The address to transfer the tokens to.\n    /// @param amount The amount of tokens to transfer.\n    function safeTransfer(address tokenAddress, address to, uint256 amount) internal returns (bool) {\n        (bool success, bytes memory data) =\n        // solhint-disable-next-line avoid-low-level-calls\n         tokenAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount));\n        if (!success) {\n            if (data.length != 0) {\n                // bubble up error\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(data)\n                    revert(add(32, data), returndata_size)\n                }\n            } else {\n                revert TransferFailed();\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "src/LiquidityLocker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { EnumerableSet } from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\nimport { IUniswapV2Factory } from \"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport { IUniswapV2Pair } from \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport { IUniswapV2Migrator } from \"lib/v2-periphery/contracts/interfaces/IUniswapV2Migrator.sol\";\n\nimport { SafeTransfer } from \"./lib/SafeTransfer.sol\";\n\n/**\n * @title LiquidityLocker\n * @author @neuro_0x\n * @dev A contract for locking Uniswap V2 liquidity pool tokens for specified periods.\n */\ncontract LiquidityLocker is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    error InvalidAmount();\n    error InvalidLockDate();\n    error LockMismatch();\n    error BeforeUnlockDate();\n    error OwnerAlreadySet();\n    error MigratorNotSet();\n    error NotUniPair(address lpToken);\n\n    IUniswapV2Factory private constant _UNISWAP_V2_FACTORY =\n        IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n\n    struct User {\n        EnumerableSet.AddressSet lockedTokens; // records all tokens the user has locked\n        mapping(address => uint256[]) locksForToken; // map erc20 address to lock id for that token\n    }\n\n    struct TokenLock {\n        uint256 lockDate; // the date the token was locked\n        uint256 amount; // the amount of tokens still locked (initialAmount minus withdrawls)\n        uint256 initialAmount; // the initial lock amount\n        uint256 unlockDate; // the date the token can be withdrawn\n        uint256 lockID; // lockID nonce per uni pair\n        address owner;\n    }\n\n    mapping(address userAddress => User user) private _users;\n\n    EnumerableSet.AddressSet private _lockedTokens;\n    mapping(address pair => TokenLock[] locks) public tokenLocks; // map univ2 pair to all its locks\n\n    IUniswapV2Migrator public migrator;\n\n    event OnWithdraw(address lpToken, uint256 amount);\n    event OnDeposit(address lpToken, address user, uint256 amount, uint256 lockDate, uint256 unlockDate);\n\n    /**\n     * @dev Set the migrator contract which allows locked lp tokens to be migrated to uniswap v3\n     * @param _migrator The address of the migrator contract\n     */\n    function setMigrator(IUniswapV2Migrator _migrator) public onlyOwner {\n        migrator = _migrator;\n    }\n\n    /**\n     * @dev Creates a new lock\n     * @param lpToken the univ2 token address\n     * @param amountOfLPToLock amount of LP tokens to lock\n     * @param unlockDate the unix timestamp (in seconds) until unlock\n     * @param withdrawer the user who can withdraw liquidity once the lock expires\n     */\n    function lockLPToken(\n        IERC20 lpToken,\n        uint256 amountOfLPToLock,\n        uint256 unlockDate,\n        address payable withdrawer\n    )\n        external\n        payable\n        nonReentrant\n        returns (TokenLock memory tokenLock)\n    {\n        if (amountOfLPToLock == 0) {\n            revert InvalidAmount();\n        }\n\n        if (unlockDate > 10_000_000_000) {\n            revert InvalidLockDate();\n        }\n\n        // ensure this pair is a univ2 pair by querying the factory\n        IUniswapV2Pair lpair = IUniswapV2Pair(address(lpToken));\n        address factoryPairAddress = _UNISWAP_V2_FACTORY.getPair(lpair.token0(), lpair.token1());\n\n        if (factoryPairAddress != address(lpToken)) {\n            revert NotUniPair(address(lpToken));\n        }\n\n        SafeTransfer.safeTransferFrom(address(lpToken), _msgSender(), address(this), amountOfLPToLock);\n\n        tokenLock.lockDate = block.timestamp;\n        tokenLock.amount = amountOfLPToLock;\n        tokenLock.initialAmount = amountOfLPToLock;\n        tokenLock.unlockDate = unlockDate;\n        tokenLock.lockID = tokenLocks[address(lpToken)].length;\n        tokenLock.owner = withdrawer;\n\n        // record the lock for the univ2pair\n        tokenLocks[address(lpToken)].push(tokenLock);\n        _lockedTokens.add(address(lpToken));\n\n        // record the lock for the user\n        User storage user = _users[withdrawer];\n        user.lockedTokens.add(address(lpToken));\n        uint256[] storage userLocks = user.locksForToken[address(lpToken)];\n        userLocks.push(tokenLock.lockID);\n\n        emit OnDeposit(address(lpToken), _msgSender(), tokenLock.amount, tokenLock.lockDate, tokenLock.unlockDate);\n    }\n\n    /**\n     * @dev extend a lock with a new unlock date, _index and _lockID ensure the correct lock is changed\n     * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\n     * @param _lpToken the univ2 token address\n     * @param _index the index of the lock for the token\n     * @param _lockID the lockID of the lock for the token\n     * @param _unlockDate the new unix timestamp (in seconds) until unlock\n     */\n    function relock(IERC20 _lpToken, uint256 _index, uint256 _lockID, uint256 _unlockDate) external nonReentrant {\n        if (_unlockDate > 10_000_000_000) {\n            revert InvalidLockDate();\n        }\n\n        // timestamp entered in seconds\n        uint256 lockID = _users[_msgSender()].locksForToken[address(_lpToken)][_index];\n        TokenLock storage userLock = tokenLocks[address(_lpToken)][lockID];\n\n        if (lockID != _lockID || userLock.owner != _msgSender()) {\n            revert LockMismatch();\n        }\n\n        if (userLock.unlockDate > _unlockDate) {\n            revert BeforeUnlockDate();\n        }\n\n        userLock.unlockDate = _unlockDate;\n    }\n\n    /**\n     * @dev withdraw a specified amount from a lock. _index and _lockID ensure the correct lock is changed\n     * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\n     */\n    function withdraw(IERC20 _lpToken, uint256 _index, uint256 _lockID, uint256 _amount) external nonReentrant {\n        if (_amount == 0) {\n            revert InvalidAmount();\n        }\n\n        uint256 lockID = _users[_msgSender()].locksForToken[address(_lpToken)][_index];\n        TokenLock storage userLock = tokenLocks[address(_lpToken)][lockID];\n\n        if (lockID != _lockID || userLock.owner != _msgSender()) {\n            revert LockMismatch();\n        }\n\n        if (userLock.unlockDate > block.timestamp) {\n            revert BeforeUnlockDate();\n        }\n\n        userLock.amount = userLock.amount - _amount;\n\n        // clean user storage\n        if (userLock.amount == 0) {\n            uint256[] storage userLocks = _users[_msgSender()].locksForToken[address(_lpToken)];\n            userLocks[_index] = userLocks[userLocks.length - 1];\n            userLocks.pop();\n            if (userLocks.length == 0) {\n                _users[_msgSender()].lockedTokens.remove(address(_lpToken));\n            }\n        }\n\n        SafeTransfer.safeTransfer(address(_lpToken), _msgSender(), _amount);\n        emit OnWithdraw(address(_lpToken), _amount);\n    }\n\n    /**\n     * @dev increase the amount of tokens per a specific lock, this is preferable to creating a new lock, less fees,\n     * and faster loading on our live block explorer\n     */\n    function incrementLock(\n        IERC20 _lpToken,\n        uint256 _index,\n        uint256 _lockID,\n        uint256 _amount\n    )\n        external\n        nonReentrant\n        returns (TokenLock memory _userLock)\n    {\n        if (_amount == 0) {\n            revert InvalidAmount();\n        }\n\n        uint256 lockID = _users[_msgSender()].locksForToken[address(_lpToken)][_index];\n        TokenLock storage userLock = tokenLocks[address(_lpToken)][lockID];\n\n        if (lockID != _lockID || userLock.owner != _msgSender()) {\n            revert LockMismatch();\n        }\n\n        SafeTransfer.safeTransferFrom(address(_lpToken), address(_msgSender()), address(this), _amount);\n\n        userLock.amount = userLock.amount + _amount;\n\n        emit OnDeposit(address(_lpToken), _msgSender(), userLock.amount, userLock.lockDate, userLock.unlockDate);\n\n        return userLock;\n    }\n\n    /**\n     * @dev transfer a lock to a new owner, e.g. presale project -> project owner\n     */\n    function transferLockOwnership(\n        address _lpToken,\n        uint256 _index,\n        uint256 _lockID,\n        address payable _newOwner\n    )\n        external\n    {\n        if (_newOwner == owner()) {\n            revert OwnerAlreadySet();\n        }\n\n        uint256 lockID = _users[_msgSender()].locksForToken[_lpToken][_index];\n        TokenLock storage transferredLock = tokenLocks[_lpToken][lockID];\n\n        if (lockID != _lockID || transferredLock.owner != _msgSender()) {\n            revert LockMismatch();\n        }\n\n        // record the lock for the new Owner\n        User storage user = _users[_newOwner];\n        user.lockedTokens.add(_lpToken);\n\n        uint256[] storage userLocks = user.locksForToken[_lpToken];\n        userLocks.push(transferredLock.lockID);\n\n        // remove the lock from the old owner\n        uint256[] storage userLocks2 = _users[_msgSender()].locksForToken[_lpToken];\n        userLocks2[_index] = userLocks2[userLocks2.length - 1];\n        userLocks2.pop();\n\n        if (userLocks2.length == 0) {\n            _users[_msgSender()].lockedTokens.remove(_lpToken);\n        }\n\n        transferredLock.owner = _newOwner;\n    }\n\n    /**\n     * @dev migrates liquidity to uniswap v3\n     */\n    function migrate(IERC20 _lpToken, uint256 _index, uint256 _lockID, uint256 _amount) external nonReentrant {\n        if (address(migrator) == address(0)) {\n            revert MigratorNotSet();\n        }\n\n        if (_amount == 0) {\n            revert InvalidAmount();\n        }\n\n        uint256 lockID = _users[_msgSender()].locksForToken[address(_lpToken)][_index];\n        TokenLock storage userLock = tokenLocks[address(_lpToken)][lockID];\n\n        if (lockID != _lockID || userLock.owner != _msgSender()) {\n            revert LockMismatch();\n        }\n\n        userLock.amount = userLock.amount - _amount;\n\n        // clean user storage\n        if (userLock.amount == 0) {\n            uint256[] storage userLocks = _users[_msgSender()].locksForToken[address(_lpToken)];\n            userLocks[_index] = userLocks[userLocks.length - 1];\n            userLocks.pop();\n            if (userLocks.length == 0) {\n                _users[_msgSender()].lockedTokens.remove(address(_lpToken));\n            }\n        }\n\n        IERC20(_lpToken).approve(address(migrator), _amount);\n        migrator.migrate(address(_lpToken), _amount, userLock.unlockDate, _msgSender(), block.timestamp + 1 days);\n    }\n\n    /**\n     * @dev Get the number of locks for a specific token.\n     * @param _lpToken The address of the LP token.\n     */\n    function getNumLocksForToken(address _lpToken) external view returns (uint256) {\n        return tokenLocks[_lpToken].length;\n    }\n\n    /**\n     * @dev Get the total number of locked tokens\n     */\n    function getNumLockedTokens() external view returns (uint256) {\n        return _lockedTokens.length();\n    }\n\n    /**\n     * @dev Get the address of a locked token at an index.\n     * @param _index The index of the token.\n     */\n    function getLockedTokenAtIndex(uint256 _index) external view returns (address) {\n        return _lockedTokens.at(_index);\n    }\n\n    /**\n     * @dev Get the number of tokens a user has locked.\n     * @param _user The address of the user.\n     */\n    function getUserNumLockedTokens(address _user) external view returns (uint256) {\n        User storage user = _users[_user];\n        return user.lockedTokens.length();\n    }\n\n    /**\n     * @dev Get the token address a user has locked at an index.\n     * @param _user The address of the user.\n     * @param _index The index of the token.\n     */\n    function getUserLockedTokenAtIndex(address _user, uint256 _index) external view returns (address) {\n        User storage user = _users[_user];\n        return user.lockedTokens.at(_index);\n    }\n\n    /**\n     * @dev Get the number of locks for a specific user and token.\n     * @param _user The address of the user.\n     * @param _lpToken The address of the LP token.\n     */\n    function getUserNumLocksForToken(address _user, address _lpToken) external view returns (uint256) {\n        User storage user = _users[_user];\n        return user.locksForToken[_lpToken].length;\n    }\n\n    /**\n     * @dev Get the lock for a specific user and token at an index.\n     * @param _user The address of the user.\n     * @param _lpToken The address of the LP token.\n     * @param _index The index of the lock.\n     * @return The lock date.\n     * @return Amount of tokens locked.\n     * @return Initial amount of tokens locked.\n     * @return Unlock date of the lock.\n     * @return Lock ID of the lock.\n     * @return Owner of the lock.\n     */\n    function getUserLockForTokenAtIndex(\n        address _user,\n        address _lpToken,\n        uint256 _index\n    )\n        external\n        view\n        returns (uint256, uint256, uint256, uint256, uint256, address)\n    {\n        uint256 lockID = _users[_user].locksForToken[_lpToken][_index];\n        TokenLock storage tokenLock = tokenLocks[_lpToken][lockID];\n        return (\n            tokenLock.lockDate,\n            tokenLock.amount,\n            tokenLock.initialAmount,\n            tokenLock.unlockDate,\n            tokenLock.lockID,\n            tokenLock.owner\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363935333336333037313732"
      }
    }
  }
}